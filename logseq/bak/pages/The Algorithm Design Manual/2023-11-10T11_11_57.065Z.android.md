type:: [[book]]
cover:: ![the_algorithm_design_manual_cover.jpg](../assets/the_algorithm_design_manual_cover_1696794828057_0.jpg) 
title:: The Algorithm Design Manual
author:: [[Steven Sol Skiena]]
topics:: #[[software development]] #algorithms #[[data structure]] 
file:: ![The Algorithm Design Manual by Steven S. Skiena.pdf](../assets/The_Algorithm_Design_Manual_by_Steven_S._Skiena_1696794666730_0.pdf) 
status:: #[[ðŸŒ¿ to plant]]

-
- ## What is an Algorithm?
	- It is a procedure to accomplish a specific task.
	- It should solve a general, well specified [[problem]]. AKA it should solve every [[instance]] of the given problem
	- A good [[algorithm]] should be [[correct]], [[efficient]] and the [[implementation]] has to be easy
	- A proof of correctness is required to demonstrate that a particular [[algorithm]] is [[correct]]
	- A proof of incorrectness is required to demonstrate that a particular [[algorithm]] or [[heuristics]] does is incorrect
	- You should aim at developing [[algorithms]], not [[heuristics]], even if heuristics may usually do a good job, it is not guaranteed
	- Ensuring the optimal answer over all possible inputs is a difficult but often achievable goal. Seek to [[problem]] [[instance]]s that breaks the algorithm
	-
- ## Correctness Demonstration Tools:
	- ### Correctness Proof
		- A mathematical [[proof]] is composed by a clear [[statement]], a set of [[assumptions]] involved in the process of proving the statement and than a [[chain of reasoning]] which takes you from the assumptions to the statement you are trying to prove
		- Usually [[mathematical induction]] is the demonstrating method of choice because many of the [[algorithm]]s are either recursive or incremental
		- Be suspicious about [[mathematical induction]] proofs, they can hide really subtle reasoning errors (eg: extreme cases might not be considered)
		-
	- ### Expressing Algorithms
		- Before even trying to write an [[algorithm]] in a [[programming language]] , you should think carefully about the sequence of [[steps]] to be performed
		- The heart of any [[algorithm]] is the fundamental idea. If your idea is not clearly revealed when you express an algorithm, then you are using too low-level a notation to describe it
		-
	- ### Problem description and Properties
		- In order to develop a correct [[algorithm]], you should first focus on understanding the problem description and requirements
		- Problem specifications have two parts:
			- #### Set of allowed input instances
				- Narrow the set of allowable input instances until there is a [[correct]] and [[efficient]] [[algorithm]]. (eg: we can restrict a graph problem from general graphs down to binary trees)
			- #### Required properties of the algorithm's output
				- Requirements should be clear and well defined (eg: asking for the "best" route between two places is a silly question. Define what do you mean with "best", it can mean the fastest, or the cheapest, etc...)
				- Avoid creating compound [[goals]]. (eg: "Find the shortest path from a to b (1), that doesn't use more than twice as many turns as necessary (2)". Here there are two goals compounded)
				- Finding the right formulation for your problem is an important part of solving it
				-
- ## Incorrectness Demonstration Tools
	- The best way to prove that an [[algorithm]] is [[incorrect]] is to produce an [[instance]] in which it yields an incorrect answer. This instance is called a [[counter-example]]
	-
	- ### Properties of a good [[counter-example]]
		- #### Verifiability
			- Calculate the wrong [[algorithm]] output for a given [[problem]] [[instance]]
			- Show the correct result, what the [[algorithm]] should have given as output in order to be correct
			-
		- #### Simplicity
			- Once you found a good [[counter-example]] is a good practice to boil it down to its essence (eg: A sorting algorithm is incorrect for a given instance? Create a simpler instance of the problem with the same properties (like a smaller array of elements to sort))
			-
	- ### How to find a good [[counter-example]]
		- #### Think small
			- Try small problem [[instances]]
			- Big instances are more difficult to think about, and to reason on
			-
		- #### Think exhaustively
			- For any given instance, think carefully about the several ways in which the [[algorithm]] may fail
			-
		- #### Hunt for weakness
			- Figure out what are the weaknesses of the [[algorithm]], in which parts the program may fail because of a particular input (eg: In an algorithm that tries to get the max value of a given sequence of number, figure out what will happen if the given array is populated by all the same values. It may return a correct result in a suboptimal manner)
			-
		- #### Seek extremes
			- Find [[counter-example]] that are [[extreme]]
			- Analyzing a list of muddled [[counter-example]] is inefficient, for the sake of understanding if the [[algorithm]] is correct, analyzing more extreme counter-examples is more useful
			-
- ## Summations
	- Used for [[algorithm]] analysis
	- Those are concise expression do describe the addition of an arbitrarly larte set of numbers
	- $$\sum_{i=1}^{n}f(i) = f(1) + f(2) + ... + f(n) \newline \sum_{i=1}^{n}1 = n$$
	- The sum of the first $$n$$ intergers can be seen by pairing the $$i$$th and $$(n - i + 1)$$th integers:
	- {{embed [[Teorema Somme Parziali]]}}
	-
	- The most used classes of summations formulae in [[algorithm]] analysis are
	- ### Arithmetic Progressions
		- $$S(n, p) = \sum_{i}^{n}i^p = \Theta(n^{p + 1})$$
	- ### Geometric Series
		- $$G(n, a) = \sum_{i=0}^{n}a^{i} = \frac{a(a^{n + 1} - 1)}{a - 1}$$
	-
- ## Modeling the Problem
	- Describing an application by reducing it in single problems enables the chance to relate the application to what has been done before
	- Usually problems are solved abstractly, so you have to transform you real world problem into an abstract one. Describe it in terms of procedures on fundamental structures ([[algorithm]] and [[data structure]])
	-
- ## Recursive Objects
	- Recursive objects are objects made of smaller objects of the same type of the original object.
	- Those objects should require [[decomposition rule]] and [[basis case]]
	-
- ## The RAM model of Computation
	- It is a way to measure the run time by counting the number of simple operations performed by the [[algorithm]].
	- Simple operations are (+, -, *, /, =, if) and memory access
	- Each simple operation takes one time step
	-
- ## Best, Worse and Average case Complexity
	- Thanks to the RAM model of Computation we can represent several case scenarios, and their computational costs
	- ![best_worst_average_case_complexity.png](../assets/best_worst_average_case_complexity_1699435281235_0.png){:height 423, :width 612}
	- Sometimes it might be difficult to properly define one of those [[functions]], sometimes in order to properly define one of those functions you need to insert irrelevant coding details (like "the algorithm runs thanks to a switch statement or nested ifs?")
	- To analyse each scenario we use [[Asymptotic Analysis]]
	-
- ## Growth Rates
	- Using [[Asymptotic Analysis]] we can assume that $$f(n) = n^2 \sim g(n) = 200n^2$$ even if $$g(n)$$ is 200 times bigger than $$f(n)$$
	- Below is represented a table of common functions with their related execution time
	- ![growth_rates_of_common_functions.png](../assets/growth_rates_of_common_functions_1699521413899_0.png){:height 243, :width 641}
	-
- ## Dominance Relations
	- Even if [[Big Oh Notation]] can be used upon an infinite set of possible functions, in [[algorithm]] analysis we tend to group every function into a closed set of possible function:
		- {{embed [[constant functions]]}}
		-
		- {{embed [[logarithmic functions]]}}
		-
		- {{embed [[linear functions]]}}
		-
		- {{embed [[superlinear functions]]}}
		-
		- {{embed [[quadratic functions]]}}
		-
		- {{embed [[cubic functions]]}}
		-
		- {{embed [[exponential functions]]}}
		-
		- {{embed [[factorial functions]]}}
		-
-
-